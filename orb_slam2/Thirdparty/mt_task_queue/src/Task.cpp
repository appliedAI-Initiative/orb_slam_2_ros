#include "Task.h"

namespace TaskQueue {

template <typename ReturnType, typename... Args>
/*
 * Task constructor must receive not only the task function, but also its arguments.
 */
Task<ReturnType, Args...>::Task (unsigned int task_id, unsigned int priority, std::function<ReturnType(Args...)> task_function, Args... function_args)
: task_id_(task_id), priority_(priority), task_function_(task_function), function_args_(function_args...) {
  if (task_function_.target_type() != typeid(void(*)(Args...))) { //right? TODO, WARNING, fuck, i've no idea what im doing
    has_return_value_ = true;
  } else {
    has_return_value_ = false;
  }
}

/*
 * The function required to unpack passed function arguments and call a passed function with those arguments.
 * This is essentially doing the work of std::apply, which we could use in C++17, but we have C++14, so need
 * this.
 */
template <typename Func, typename Tuple, std::size_t... Indices>
decltype(auto) CallFunctionWithTuple(Func&& func, Tuple&& args, std::index_sequence<Indices...>) {
    return func(std::get<Indices>(std::forward<Tuple>(args))...);
}

template <typename ReturnType, typename... Args>
void Task<ReturnType, Args...>::RunTask () {
  if (has_return_value_) {
    /* 
     * Unpack and call the stored function. And because the function parameters are in a tuple, we need
     * to unpack them with this CallFunctionWithTuple function. If this was C++17 or higher, then we could
     * use std::apply, but this is C++14.
     */
    result_ = CallFunctionWithTuple(task_function_, function_args_, std::index_sequence_for<Args...>());
  } else {
    /* 
     * Unpack and call the stored function. And because the function parameters are in a tuple, we need
     * to unpack them with this CallFunctionWithTuple function. If this was C++17 or higher, then we could
     * use std::apply, but this is C++14.
     */
    CallFunctionWithTuple(task_function_, function_args_, std::index_sequence_for<Args...>());
  }

}

// Explicit template instantiation for the supported types. This is needed so that the rest of the project can link to this module. If this is not here, then support for the
// required types will not be generated by the compiler.
template class Task<boost::shared_ptr<pcl::PointCloud<pcl::PointXYZRGBA>>, boost::shared_ptr<pcl::PointCloud<pcl::PointXYZRGBA>>, boost::shared_ptr<pcl::PointCloud<pcl::PointXYZRGBA>>, cv::Mat>;

} // namespace TaskQueue
