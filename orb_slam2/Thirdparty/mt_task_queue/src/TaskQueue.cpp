#include "TaskQueue.h"

namespace TaskQueue {

template <typename ReturnType, typename... Args>
TaskQueue<ReturnType, Args...>::TaskQueue (unsigned int num_worker_threads) {
  if (num_worker_threads == 0) {
    throw std::invalid_argument ("Cannot launch thread queue with 0 workers");
  }

  for (unsigned int i = 0; i < num_worker_threads; i++) {
    workers_.push_back (Worker<ReturnType, Args...> (task_queue_, results_, &queue_mutex_, &map_mutex_, condition_var_));
  }
}


template <typename ReturnType, typename... Args>
TaskQueue<ReturnType, Args...>::~TaskQueue () {
  /*
   * We need to iterate through the workers_ collection in this way- to avoid taking the Worker objects
   * out of the queue, which would cause copy-construction.
   */
  for (unsigned int i = 0; i < workers_.size(); i++) {
    workers_[i].EndWorker();
  }
}


template <typename ReturnType, typename... Args>
/*
 * AddTask needs to receive the task function alongside its parameters as a minimum.
 */
void TaskQueue<ReturnType, Args...>::AddTask (unsigned int task_id, unsigned int priority, std::function<ReturnType(Args...)> task_function, Args... function_args) {
  std::unique_lock<std::mutex> lock(queue_mutex_);
  task_queue_.push(Task<ReturnType, Args...> (task_id, priority, task_function, function_args...));
  condition_var_.notify_one();
}


template <typename ReturnType, typename... Args>
/*
 * GetTask must return a pointer to the Task object.
 */
Task<ReturnType, Args...>* TaskQueue<ReturnType, Args...>::GetTask (unsigned int task_id) {
  std::unique_lock<std::mutex> lock(map_mutex_);
  auto it = results_.find (task_id);
  if (it != results_.end()) {
    /*
     * We want to return the pointer to the Task object without getting it out of the resuts_ map, which would cause copy-constructing.
     */
    return it->second; // Return the existing Task object from the map
  } else {
    throw std::runtime_error("Result not (yet?) available");
  }
}

template <typename ReturnType, typename... Args>
bool TaskQueue<ReturnType, Args...>::ResultAvailable (unsigned int task_id) {
  std::unique_lock<std::mutex> lock(map_mutex_);
  auto it = results_.find (task_id);
  if (it != results_.end()) {
    return true;
  } else {
    return false;
  }
}


template <typename ReturnType, typename... Args>
bool TaskQueue<ReturnType, Args...>::QueueIsEmpty () {
  std::unique_lock<std::mutex> lock(queue_mutex_);
  return task_queue_.empty();
}


template <typename ReturnType, typename... Args>
unsigned int TaskQueue<ReturnType, Args...>::NumJobsCurrentlyRunning () {
  unsigned int workers_working = 0;
  /*
   * We need to iterate through the workers_ collection in this way- to avoid taking the Worker objects
   * out of the queue, which would cause copy-construction.
   */
  for (unsigned int i = 0; i < workers_.size(); i++) {
    if (!workers_[i].IsIdeling()) { //# if (workers_[i].IsIdeling()) { //# surely we want to count workers that are NOT idle though???
      workers_working ++;
    }
  }
  return workers_working;
}

// Explicit template instantiation for the supported types. This is needed so that the rest of the project can link to this module. If this is not here, then support for the
// required types will not be generated by the compiler. This is what template <typename ReturnType, typename... Args> does for the TaskQueue object.
template class TaskQueue<boost::shared_ptr<pcl::PointCloud<pcl::PointXYZRGBA> >, boost::shared_ptr<pcl::PointCloud<pcl::PointXYZRGBA> >, boost::shared_ptr<pcl::PointCloud<pcl::PointXYZRGBA> >, cv::Mat>;

} // namespace TaskQueue
